<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://marcoberlot1.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://marcoberlot1.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-06-13T16:36:16+00:00</updated><id>https://marcoberlot1.github.io/feed.xml</id><title type="html">blank</title><subtitle>Personal Website of Computer Scientist Marco Berlot.
</subtitle><entry><title type="html">How to Leverage AWS Step Functions to Build an Event-Driven Architecture</title><link href="https://marcoberlot1.github.io/blog/2022/leverage-aws-step-functions/" rel="alternate" type="text/html" title="How to Leverage AWS Step Functions to Build an Event-Driven Architecture" /><published>2022-11-20T17:03:20+00:00</published><updated>2022-11-20T17:03:20+00:00</updated><id>https://marcoberlot1.github.io/blog/2022/leverage-aws-step-functions</id><content type="html" xml:base="https://marcoberlot1.github.io/blog/2022/leverage-aws-step-functions/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Event-driven architectures have grown in popularity as they offer increased flexibility, scalability, and responsiveness to modern application demands. These architectures often involve numerous services and queues or message brokers, which can be challenging to manage. In this blog post, we’ll explore how AWS Step Functions can be a powerful tool for building and managing event-driven architectures through orchestration.</p>

<h2 id="section-1-event-driven-architectures---the-need-for-coreography-or-orchestration">Section 1: Event-Driven Architectures - The Need for Coreography or Orchestration</h2>

<p>In event-driven architectures, multiple services interact with each other through events. To manage the processes and ensure that they function smoothly, there are two primary approaches: coreography and orchestration.</p>

<ol>
  <li>
    <p><strong>Coreography</strong>: In this approach, each service is responsible for its own logic and decision-making. Services communicate with each other through events, and they make decisions based on the events they receive. This approach is more decentralized and requires less centralized management.</p>
  </li>
  <li>
    <p><strong>Orchestration</strong>: In orchestration, a central conductor or orchestrator manages the flow of events and the decision-making process. The orchestrator is responsible for coordinating the different services and ensuring that the right events are processed at the right time. This approach offers a more centralized control over the event flow.</p>
  </li>
</ol>

<h2 id="section-2-introducing-aws-step-functions-as-an-orchestration-tool">Section 2: Introducing AWS Step Functions as an Orchestration Tool</h2>

<p>Now, there are both pros and cons for these approaches, but the point of this article is not to consider them, or evaluate how once can be better than the other given a certain context. We’re going to focus on the Orchestration approach, and see how AWS Step Functions can be a great tool to build a serverless orchestrator.</p>

<p>AWS Step Functions is a serverless workflow service that enables you to create, coordinate, and manage complex processes across multiple services. It acts as an orchestrator, providing a way to coordinate and manage the flow of events in an event-driven architecture.
In addition to being an orchestrator, Step Functions also provides the following features:</p>

<ul>
  <li>Visualize and define your workflows using a JSON-based language called the Amazon States Language.</li>
  <li>Automatically handle retries and error handling.</li>
  <li>Easily integrate with other AWS services such as AWS Lambda, Amazon SNS, and Amazon SQS.</li>
  <li>Monitor and track the execution of your workflows in real-time.</li>
</ul>

<h2 id="section-3-example---building-an-event-driven-architecture-with-aws-step-functions">Section 3: Example - Building an Event-Driven Architecture with AWS Step Functions</h2>

<p>To better understand how AWS Step Functions can be employed in an event-driven architecture, let’s walk through a simple example. Imagine you’re building an online retail store and need to process client orders coming from the web application. To simplify, let’s assume the following steps must occur:</p>

<ol>
  <li>Upon receiving an order, you need to process the payment.</li>
  <li>After payment is processed, the system should place the item “on hold,” ensuring that no one else can purchase it.</li>
  <li>Finally, the system must initiate the shipping process for the item.</li>
</ol>

<p>Now, let’s envision that we have three separate services to handle these tasks: one for payments, one for updating the item’s status, and one for managing the shipping process. Each service reads incoming events from a queue. What we can create is a Step Functions workflow that sends one message per step to the respective queue for each service. Refer to the example from the Step Functions workflow editor below:</p>

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/stepfunction-1-480.webp" />
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/stepfunction-1-800.webp" />
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/stepfunction-1-1400.webp" />
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/stepfunction-1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />

  </picture>

</figure>

    </div>
</div>

<p>With this simple approach we got a lot out of the box:</p>

<ul>
  <li>We guarantee that if one step fails, we’re not going to proceed to the next step. For example, if we can’t process the payment, we’re not going to proceed and update the status of the item. (This only applies if the operation the service is performing is a synchronous operation)</li>
  <li>We can visualize all the workflows, and see when/how they fail</li>
  <li>Serverless and highly scalable</li>
</ul>

<p>You can easily see how this can be extremely useful with more complex scenarios, that involve more services and longer workflows.</p>

<h2 id="cons-of-using-step-functions">Cons of using Step Functions</h2>

<p>Now let’s discuss some of the primary drawbacks of using Step Functions. In my opinion, there are two significant disadvantages:</p>

<p>Step Functions cannot scale indefinitely. There is a limit to the number of state transitions per second allowed on your AWS account. This number depends on the type of workflows you’re employing, but it can be a constraint.
Cost. As with all cloud services, there is an associated expense, which can increase significantly at a higher scale.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Leveraging AWS Step Functions to build event-driven architectures offers a powerful way to manage and coordinate complex processes across multiple services. By using Step Functions as an orchestration tool, you can create robust, scalable, and easy-to-maintain systems, ensuring that your applications are responsive to the dynamic demands of the modern world.</p>]]></content><author><name></name></author><category term="technical" /><category term="aws" /><summary type="html"><![CDATA[Introducing AWS Step Functions as an Orchestration Tool]]></summary></entry><entry><title type="html">What Are Database Migrations and Why You Should Use Them</title><link href="https://marcoberlot1.github.io/blog/2022/database-migrations/" rel="alternate" type="text/html" title="What Are Database Migrations and Why You Should Use Them" /><published>2022-09-20T17:03:20+00:00</published><updated>2022-09-20T17:03:20+00:00</updated><id>https://marcoberlot1.github.io/blog/2022/database-migrations</id><content type="html" xml:base="https://marcoberlot1.github.io/blog/2022/database-migrations/"><![CDATA[<h2 id="the-critical-role-of-database-migrations-in-software-development">The Critical Role of Database Migrations in Software Development</h2>

<p>As the complexity of software systems has increased over time, so too has the intricacy of managing the foundational component of these systems. Databases are one of the most integral part of these systems. In this post, we’ll delve into the importance of using database migrations to track and control changes in your database schema, and why they serve as a vital tool in your software development lifecycle.</p>

<h2 id="the-issue-in-not-tracking-the-database-schema">The Issue in Not Tracking the Database Schema</h2>

<p>The state of your database is critical to the operation of your software. Imagine a database as a warehouse where your application stores and retrieves its data. The warehouse needs to be organized in a certain way for the application to work properly. This organization, in terms of a database, is the schema.</p>

<p>If you aren’t properly tracking changes to this schema, you can end up with a myriad of issues. For instance, a new feature might require a change in the database schema, which, if not managed properly, could cause inconsistencies between environments. An example of such inconsistency would be a feature working perfectly fine in the development environment, but failing in the production environment due to a schema discrepancy.</p>

<p>This lack of control and visibility can lead to bugs, system downtime, data loss, and significant issues during scaling, not to mention the time and resources spent on troubleshooting and resolving these issues.</p>

<p>I’ve seen several companies running databases in production, without a schema versioning system, for which, no one really knew what was the latest status of the database. The only way for you to know was to go and actually check the schemas of the tables in production.</p>

<h2 id="migrations-a-functional-and-elegant-solution">Migrations: A Functional and Elegant Solution</h2>

<p>Database migrations provide a functional and elegant solution to these challenges. A database migration is essentially a set of instructions that makes changes to the database schema, such as creating a table, adding a column, or updating data within the table.</p>

<p>Database migrations are version-controlled, which means that they not only track the changes but also the sequence in which they were made. This enables you to replicate your database schema in a new environment reliably and accurately, or roll back changes if something goes wrong.</p>

<p>In essence, database migrations bring predictability, visibility, and control to your database management, while facilitating collaboration between team members.</p>

<h2 id="a-practical-example">A Practical Example</h2>

<p>To illustrate the concept, consider a scenario where we are developing a blog platform. Initially, we create a Posts table with columns title and body. After some time, we decide to add a feature to like a post. For this, we need a new column likes in the Posts table.</p>

<p>Instead of manually adding this column in every environment, we write a migration. This migration contains instructions to alter the Posts table and add the likes column.</p>

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/migration-1-480.webp" />
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/migration-1-800.webp" />
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/migration-1-1400.webp" />
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/migration-1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />

  </picture>

</figure>

    </div>
</div>
<div class="caption">
    A simple, elegant caption looks good between image rows, after each row, or doesn't have to be there at all.
</div>

<p>We then run this migration in each environment (development, testing, production), ensuring the database schema is consistent across all of them.</p>

<p>Now, our database schema is built based off the two migrations you can see below. This means that simply from the code we can know what the schema looks like for each version, without the need to go and check our database</p>

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/migration-2-480.webp" />
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/migration-2-800.webp" />
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/migration-2-1400.webp" />
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/migration-2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />

  </picture>

</figure>

    </div>
</div>
<div class="caption">
    A simple, elegant caption looks good between image rows, after each row, or doesn't have to be there at all.
</div>

<p>If, in the future, we decide to remove this feature, we can simply write another migration to remove the likes column.</p>

<h2 id="integration-tests-an-additional-benefit">Integration Tests: An Additional Benefit</h2>

<p>Suppose we need to conduct a minor integration test involving a method that interacts with our database. Leveraging migrations simplifies this process immensely. We can effortlessly spin up a local database container and construct its schema using these migrations. Consequently, the test will always incorporate the latest schema changes. If a new migration is introduced into the main branch, the test will also incorporate that migration when spinning up the local container.</p>

<h2 id="common-migration-frameworks">Common Migration Frameworks</h2>

<p>There are many robust migration frameworks available that support various languages and databases. Here are a few:</p>

<p>Flyway: This is a popular choice for Java-based applications, though it does offer command-line tools for non-Java applications. It’s easy to set up and supports both SQL-based and Java-based migrations.</p>

<p>Liquibase: Another strong contender, particularly for complex database schemas. Liquibase supports XML, YAML, JSON, and SQL format migrations and offers robust rollbacks.</p>

<p>Django Migrations: If you’re working with Django (a Python web framework), Django’s migrations are baked right into the framework and are easy to work with.</p>

<p>Rails Active Record Migrations: Similarly, if you’re working with Ruby on Rails, Active Record provides a powerful ORM tool, which includes migrations.</p>

<p>Knex.js: For JavaScript applications, Knex.js is a popular choice.</p>]]></content><author><name></name></author><category term="technical" /><category term="databases" /><summary type="html"><![CDATA[The Critical Role of Database Migrations in Software Development]]></summary></entry><entry><title type="html">Displaying External Posts on Your al-folio Blog</title><link href="https://marcoberlot1.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog/" rel="alternate" type="text/html" title="Displaying External Posts on Your al-folio Blog" /><published>2022-04-23T23:20:09+00:00</published><updated>2022-04-23T23:20:09+00:00</updated><id>https://marcoberlot1.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog</id><content type="html" xml:base="https://marcoberlot1.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog/"><![CDATA[]]></content><author><name></name></author></entry></feed>