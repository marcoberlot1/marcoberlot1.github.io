<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://marcoberlot1.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://marcoberlot1.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-07-07T16:02:25+00:00</updated><id>https://marcoberlot1.github.io/feed.xml</id><title type="html">blank</title><subtitle>Personal Website of Computer Scientist Marco Berlot.
</subtitle><entry><title type="html">What Are Time Series Databases</title><link href="https://marcoberlot1.github.io/blog/2023/what-are-time-series-databases/" rel="alternate" type="text/html" title="What Are Time Series Databases" /><published>2023-07-01T00:00:00+00:00</published><updated>2023-07-01T00:00:00+00:00</updated><id>https://marcoberlot1.github.io/blog/2023/what-are-time-series-databases</id><content type="html" xml:base="https://marcoberlot1.github.io/blog/2023/what-are-time-series-databases/"><![CDATA[<h1 id="why-and-when-to-use-time-series-databases">Why and when to use Time Series Databases</h1>

<p><img src="https://www.imsl.com/sites/default/files/image/2020-07/image-blog-time-series-analysis.jpg" alt="enter image description here" /></p>

<h2 id="a-common-scenario">A common scenario</h2>

<p>Imagine that you’re building a trading platform. Your software processes millions of orders a day. One key feature you need to build is an api to access the prices of these trades. You need to be able to return the prices for a given stock, over a particular time frame.
Additionally you might need to return an aggregate of the results, such as the weekly price for a given stock over a period of 12 months. Or potentially a more complex use case, such as “the highest price of each day over a period of 6 months”.
When you think about the fact that this api will be used in several UIs to build very complex graphs you can easily see how storing these data in the right format is key to the success of this feature. And we just mentioned what the api needs to returns, but of course we need to think about scalability, performance and cost. What I gave you is a simple example, but it can translate into several use cases. From data acquired through sensors that need to be visualized through dashboards and graphs, all the way to scientific use cases that need to deal with million of data points that describe events over time (think of number of covid cases in each city in a given country)
Well, all of these, are perfect use case for time series databases</p>

<h2 id="first-things-first-whats-a-time-series">First things first: What’s a time series?</h2>

<p><img src="https://lh4.googleusercontent.com/OVnEMWIFN_bwoyiEGYu2xsFdTuG9pF4sR4k4-CTx9EN7zZ5Ee47dSWjaWwg4gLqchJoB7no18KEpxVXcaAAKvrVpuq_82lEoMj6D0Dg7gIxXNoiZ7kbEgMN81OA8ySNJArYGirhqYCTB1M9B_vC-jKvaNDCOZqEnNBq-j9OkZDCWRQhqMBZfSdr8vg" alt="enter image description here" /></p>

<p>Think of time series as data that exists exclusively in relation to time. For instance, a trade price only holds meaning when accompanied by a specific point in time. If I told you, this Google stock is worth $100, you might assume, this is the <em>latest</em> price, or maybe the <em>average</em> price of this week. But without giving the time relation, this data point doesn’t hold any meaning.
This is different if we compare this case to, for example, data about the account of a user. The name, email, address of a user have their own meaning, even without the concept of time.
Another crucial attribute of time series data is its immutability; once recorded, it typically remains unaltered. The price of a google stock a week ago, will always be the same. Same thing for the number of covid cases in NYC January 1st 2021.</p>

<p>Now, if you think about this, we’re already describing a dataset that holds some unique properties:</p>

<ul>
  <li>Data immutability over time</li>
  <li>Each point exists in relation with a timestamp</li>
</ul>

<p>These are exactly the two properties that time series technology use to build an ad hoc solution that allows the storing and retrieval of this data in a much more optimized way compared to traditional SQL databases.</p>

<h2 id="how-do-time-series-databases-work">How do Time Series Databases Work?</h2>

<p>As we mentioned, time series databases are engines optimized to store, manage, and query time series data. These technologies offer several advantages over a traditional SQL database:</p>

<ul>
  <li>
    <p><strong>Time series databases are easier to scale.</strong> With time series databases we get partitioning out of the box. Forget about sharding, or similar techniques, thanks to the fact that each record is associated with a specific time stamp, it’s much easier for the database to manage the partitions for us. If you’re unfamiliar with partitions, think of a partitioned database as a very well organized set of files. The more the database grows, the more file it needs to hold all the records. The hard thing about this process is, how do you divide records across these files? You might need a key, or an id, to group them, so that records with the same key, can be found in the same file. The great thing about time series, is that they do not need this key, because they all have a timestamp. So you can imagine each of these files as a group of dates (such as all the records of a given month, day or week)</p>
  </li>
  <li>
    <p><strong>Time series databases can have different storage layers based on the timestamp.</strong> Newer records may be cached in memory, older records can be stored on disks, and the oldest records can be saved directly on a file. Several time series technology offer these type of configurations, and they end up in better performance and reduced cost.</p>
  </li>
  <li>
    <p><strong>They facilitate support for rollups.</strong>
Explaining rollups in depth in this article would be out of scope. But think of them as a way of aggregating data into smaller samples. For example, thinking about our trade prices: we might store thousands of trades a day. But we need to have an api that returns just the average price for each day. Instead of calculating the average price at query time, a better approach would be to pre-aggregate those averages in a different table. This pre-aggregation process is not always trivial, but most timeseries technologies have great features to support that, such as <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/scheduledqueries.html">Timestream Scheduled Queries</a> or <a href="https://docs.timescale.com/use-timescale/latest/continuous-aggregates/hierarchical-continuous-aggregates/">Timescales continuous aggregates</a></p>
  </li>
  <li>
    <p><strong>Data Compression</strong>
Similar to sound compression algorithms, time series databases can store the difference between consecutive data points rather than the actual values. Leveraging this intuition most time series technology use <a href="https://www.timescale.com/blog/time-series-compression-algorithms-explained/">state of the art compression algorithm</a>. To give you an idea, some timescale db customers claimed to have saved up <a href="https://www.timescale.com/features/compression">to 94% of</a> storage thanks to compression. You can imagine, how this can have a huge impact on costs.</p>
  </li>
  <li>
    <p><strong>Ad Hoc Functions to Manipulate Time</strong>
Timeseries have a much better support to handle queries that deal with time, compared to traditional SQL databases. A non exhaustive list includes: interpolation, date extration, and support for several time formats. You can get an idea by taking a look at <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/date-time-functions.html">Timestream’s date/time functions</a> <a href="https://docs.influxdata.com/influxdb/cloud-serverless/reference/sql/functions/time-and-date/">and InfluxDB time functions</a></p>
  </li>
</ul>

<h2 id="when-should-you-use-a-time-series-database">When Should You Use a Time Series Database</h2>

<p>Now that we’ve gone through how time series databases work and the use cases they solve, the question of “when should you use it”, it pretty straightforward.
If you’re dealing with time series data, and you expect to deal with one or more of the following use cases:</p>

<ul>
  <li>Extracting data over specific period of times</li>
  <li>Aggregations of those data into different time frames</li>
  <li>Need to scale</li>
</ul>

<p>Then you should definitely consider using one of them.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Why and when to use Time Series Databases]]></summary></entry><entry><title type="html">How to Leverage AWS Step Functions to Build an Event-Driven Architecture</title><link href="https://marcoberlot1.github.io/blog/2022/leverage-aws-step-functions/" rel="alternate" type="text/html" title="How to Leverage AWS Step Functions to Build an Event-Driven Architecture" /><published>2022-11-20T17:03:20+00:00</published><updated>2022-11-20T17:03:20+00:00</updated><id>https://marcoberlot1.github.io/blog/2022/leverage-aws-step-functions</id><content type="html" xml:base="https://marcoberlot1.github.io/blog/2022/leverage-aws-step-functions/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Event-driven architectures have grown in popularity as they offer increased flexibility, scalability, and responsiveness to modern application demands. These architectures often involve numerous services and queues or message brokers, which can be challenging to manage. In this blog post, we’ll explore how AWS Step Functions can be a powerful tool for building and managing event-driven architectures through orchestration.</p>

<h2 id="section-1-event-driven-architectures---the-need-for-coreography-or-orchestration">Section 1: Event-Driven Architectures - The Need for Coreography or Orchestration</h2>

<p>In event-driven architectures, multiple services interact with each other through events. To manage the processes and ensure that they function smoothly, there are two primary approaches: coreography and orchestration.</p>

<ol>
  <li>
    <p><strong>Coreography</strong>: In this approach, each service is responsible for its own logic and decision-making. Services communicate with each other through events, and they make decisions based on the events they receive. This approach is more decentralized and requires less centralized management.</p>
  </li>
  <li>
    <p><strong>Orchestration</strong>: In orchestration, a central conductor or orchestrator manages the flow of events and the decision-making process. The orchestrator is responsible for coordinating the different services and ensuring that the right events are processed at the right time. This approach offers a more centralized control over the event flow.</p>
  </li>
</ol>

<h2 id="section-2-introducing-aws-step-functions-as-an-orchestration-tool">Section 2: Introducing AWS Step Functions as an Orchestration Tool</h2>

<p>Now, there are both pros and cons for these approaches, but the point of this article is not to consider them, or evaluate how once can be better than the other given a certain context. We’re going to focus on the Orchestration approach, and see how AWS Step Functions can be a great tool to build a serverless orchestrator.</p>

<p>AWS Step Functions is a serverless workflow service that enables you to create, coordinate, and manage complex processes across multiple services. It acts as an orchestrator, providing a way to coordinate and manage the flow of events in an event-driven architecture.
In addition to being an orchestrator, Step Functions also provides the following features:</p>

<ul>
  <li>Visualize and define your workflows using a JSON-based language called the Amazon States Language.</li>
  <li>Automatically handle retries and error handling.</li>
  <li>Easily integrate with other AWS services such as AWS Lambda, Amazon SNS, and Amazon SQS.</li>
  <li>Monitor and track the execution of your workflows in real-time.</li>
</ul>

<h2 id="section-3-example---building-an-event-driven-architecture-with-aws-step-functions">Section 3: Example - Building an Event-Driven Architecture with AWS Step Functions</h2>

<p>To better understand how AWS Step Functions can be employed in an event-driven architecture, let’s walk through a simple example. Imagine you’re building an online retail store and need to process client orders coming from the web application. To simplify, let’s assume the following steps must occur:</p>

<ol>
  <li>Upon receiving an order, you need to process the payment.</li>
  <li>After payment is processed, the system should place the item “on hold,” ensuring that no one else can purchase it.</li>
  <li>Finally, the system must initiate the shipping process for the item.</li>
</ol>

<p>Now, let’s envision that we have three separate services to handle these tasks: one for payments, one for updating the item’s status, and one for managing the shipping process. Each service reads incoming events from a queue. What we can create is a Step Functions workflow that sends one message per step to the respective queue for each service. Refer to the example from the Step Functions workflow editor below:</p>

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/stepfunction-1-480.webp" />
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/stepfunction-1-800.webp" />
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/stepfunction-1-1400.webp" />
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/stepfunction-1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />

  </picture>

</figure>

    </div>
</div>

<p>With this simple approach we got a lot out of the box:</p>

<ul>
  <li>We guarantee that if one step fails, we’re not going to proceed to the next step. For example, if we can’t process the payment, we’re not going to proceed and update the status of the item. (This only applies if the operation the service is performing is a synchronous operation)</li>
  <li>We can visualize all the workflows, and see when/how they fail</li>
  <li>Serverless and highly scalable</li>
</ul>

<p>You can easily see how this can be extremely useful with more complex scenarios, that involve more services and longer workflows.</p>

<h2 id="cons-of-using-step-functions">Cons of using Step Functions</h2>

<p>Now let’s discuss some of the primary drawbacks of using Step Functions. In my opinion, there are two significant disadvantages:</p>

<p>Step Functions cannot scale indefinitely. There is a limit to the number of state transitions per second allowed on your AWS account. This number depends on the type of workflows you’re employing, but it can be a constraint.
Cost. As with all cloud services, there is an associated expense, which can increase significantly at a higher scale.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Leveraging AWS Step Functions to build event-driven architectures offers a powerful way to manage and coordinate complex processes across multiple services. By using Step Functions as an orchestration tool, you can create robust, scalable, and easy-to-maintain systems, ensuring that your applications are responsive to the dynamic demands of the modern world.</p>]]></content><author><name></name></author><category term="technical" /><category term="aws" /><summary type="html"><![CDATA[Introducing AWS Step Functions as an Orchestration Tool]]></summary></entry><entry><title type="html">What Are Database Migrations and Why You Should Use Them</title><link href="https://marcoberlot1.github.io/blog/2022/database-migrations/" rel="alternate" type="text/html" title="What Are Database Migrations and Why You Should Use Them" /><published>2022-09-20T17:03:20+00:00</published><updated>2022-09-20T17:03:20+00:00</updated><id>https://marcoberlot1.github.io/blog/2022/database-migrations</id><content type="html" xml:base="https://marcoberlot1.github.io/blog/2022/database-migrations/"><![CDATA[<h2 id="the-critical-role-of-database-migrations-in-software-development">The Critical Role of Database Migrations in Software Development</h2>

<p>As the complexity of software systems has increased over time, so too has the intricacy of managing the foundational component of these systems. Databases are one of the most integral part of these systems. In this post, we’ll delve into the importance of using database migrations to track and control changes in your database schema, and why they serve as a vital tool in your software development lifecycle.</p>

<h2 id="the-issue-in-not-tracking-the-database-schema">The Issue in Not Tracking the Database Schema</h2>

<p>The state of your database is critical to the operation of your software. Imagine a database as a warehouse where your application stores and retrieves its data. The warehouse needs to be organized in a certain way for the application to work properly. This organization, in terms of a database, is the schema.</p>

<p>If you aren’t properly tracking changes to this schema, you can end up with a myriad of issues. For instance, a new feature might require a change in the database schema, which, if not managed properly, could cause inconsistencies between environments. An example of such inconsistency would be a feature working perfectly fine in the development environment, but failing in the production environment due to a schema discrepancy.</p>

<p>This lack of control and visibility can lead to bugs, system downtime, data loss, and significant issues during scaling, not to mention the time and resources spent on troubleshooting and resolving these issues.</p>

<p>I’ve seen several companies running databases in production, without a schema versioning system, for which, no one really knew what was the latest status of the database. The only way for you to know was to go and actually check the schemas of the tables in production.</p>

<h2 id="migrations-a-functional-and-elegant-solution">Migrations: A Functional and Elegant Solution</h2>

<p>Database migrations provide a functional and elegant solution to these challenges. A database migration is essentially a set of instructions that makes changes to the database schema, such as creating a table, adding a column, or updating data within the table.</p>

<p>Database migrations are version-controlled, which means that they not only track the changes but also the sequence in which they were made. This enables you to replicate your database schema in a new environment reliably and accurately, or roll back changes if something goes wrong.</p>

<p>In essence, database migrations bring predictability, visibility, and control to your database management, while facilitating collaboration between team members.</p>

<h2 id="a-practical-example">A Practical Example</h2>

<p>To illustrate the concept, consider a scenario where we are developing a blog platform. Initially, we create a Posts table with columns title and body. After some time, we decide to add a feature to like a post. For this, we need a new column likes in the Posts table.</p>

<p>Instead of manually adding this column in every environment, we write a migration. This migration contains instructions to alter the Posts table and add the likes column.</p>

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/migration-1-480.webp" />
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/migration-1-800.webp" />
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/migration-1-1400.webp" />
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/migration-1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />

  </picture>

</figure>

    </div>
</div>
<div class="caption">
    A simple, elegant caption looks good between image rows, after each row, or doesn't have to be there at all.
</div>

<p>We then run this migration in each environment (development, testing, production), ensuring the database schema is consistent across all of them.</p>

<p>Now, our database schema is built based off the two migrations you can see below. This means that simply from the code we can know what the schema looks like for each version, without the need to go and check our database</p>

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/migration-2-480.webp" />
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/migration-2-800.webp" />
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/migration-2-1400.webp" />
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/migration-2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();" />

  </picture>

</figure>

    </div>
</div>
<div class="caption">
    A simple, elegant caption looks good between image rows, after each row, or doesn't have to be there at all.
</div>

<p>If, in the future, we decide to remove this feature, we can simply write another migration to remove the likes column.</p>

<h2 id="integration-tests-an-additional-benefit">Integration Tests: An Additional Benefit</h2>

<p>Suppose we need to conduct a minor integration test involving a method that interacts with our database. Leveraging migrations simplifies this process immensely. We can effortlessly spin up a local database container and construct its schema using these migrations. Consequently, the test will always incorporate the latest schema changes. If a new migration is introduced into the main branch, the test will also incorporate that migration when spinning up the local container.</p>

<h2 id="common-migration-frameworks">Common Migration Frameworks</h2>

<p>There are many robust migration frameworks available that support various languages and databases. Here are a few:</p>

<p>Flyway: This is a popular choice for Java-based applications, though it does offer command-line tools for non-Java applications. It’s easy to set up and supports both SQL-based and Java-based migrations.</p>

<p>Liquibase: Another strong contender, particularly for complex database schemas. Liquibase supports XML, YAML, JSON, and SQL format migrations and offers robust rollbacks.</p>

<p>Django Migrations: If you’re working with Django (a Python web framework), Django’s migrations are baked right into the framework and are easy to work with.</p>

<p>Rails Active Record Migrations: Similarly, if you’re working with Ruby on Rails, Active Record provides a powerful ORM tool, which includes migrations.</p>

<p>Knex.js: For JavaScript applications, Knex.js is a popular choice.</p>]]></content><author><name></name></author><category term="technical" /><category term="databases" /><summary type="html"><![CDATA[The Critical Role of Database Migrations in Software Development]]></summary></entry></feed>